Why Build Tools are Needed (WHY)
	
	Problem:	
			Imagine 100 developers:
		
				Writing code
				Using different machines
				Different versions of libraries
				Problems without build tools:
		
			Manual compilation:
		
				Manual compilation 		→ error-prone and slow
				Dependency conflicts 		→ different library versions
				“Works on my machine” issue 	→ configuration/version mismatch
				No automation 			→ repetitive, hectic, and unreliable work
	solution:
	
				Standard build process
				Automation
				Repeatable builds
				CI/CD friendly


DEVOPS BUILD TOOL WORKFLOW
 
In DevOps, build tools play a crucial role in automating the process of transforming source code into deployable artifacts and ensuring code quality through testing. The workflow integrates continuous integration (CI) and continuous delivery/deployment (CD) practices.

1.Source Code Management (SCM)
		Tools: Git, GitHub, GitLab, SVN, Bitbucket
		
		Workflow:
				Developers write code and push changes to the version control repository.
				CI/CD pipelines are triggered on code commits, merges, or pull requests.
				This ensures every code change is automatically tracked and built, creating a foundation for automation.

2.Build Stage (Separation of Concerns):
		Convert source code into deployable artifacts, such as binaries, packages, or Docker images.
		This stage only focuses on compiling code and packaging, not testing logic.

		Tools: Maven, Gradle, Ant (Java), MSBuild (C#), npm/Yarn (Node.js), Docker
		
		Workflow:
				Resolve dependencies.
				Compile source code.
				Generate artifacts (JAR, WAR, DLL, Docker images, etc.).

		Benefits:
				Faster Feedback Loops: If the build fails, developers immediately know there’s a compilation or dependency problem.
				Artifact Reusability: Built artifacts can be used across multiple test suites or environments without rebuilding.
		
3. Test Stage (Separation of Concerns):
		Verify the correctness and quality of the built artifacts.
		This stage doesn’t recompile code; it only tests behavior and integration.

		Types of Tests:
			Unit Tests → Check individual components.
			Integration Tests → Validate interactions between components.
			Functional / UI Tests → Ensure application works as expected.
			Static Code Analysis → Tools like SonarQube for code quality.
			
		Workflow:
				Fetch the artifact from the build stage.
				Execute automated tests.
				Provide feedback on pass/fail results.
				
		Benefits:
				Faster Feedback Loops: Failures pinpoint logic or integration issues, not build problems.
				Parallelization & Optimization: Different tests can run in parallel, saving time.

4. Artifact Management : 
			Store built and tested artifacts in a central repository for deployment.
			Tools: Nexus, Artifactory, Docker Registry, AWS S3

		Workflow:
				Assign version numbers to artifacts.
				Store in repository for use in multiple environments.

		Benefits:
				Only verified artifacts proceed to deployment,so that it reduces the risk of deploying broken or untested code.

5. Deployment / Delivery : 
			Deploy tested artifacts to different environments (staging, production).
			Tools: Jenkins, Ansible, Puppet, Chef, Kubernetes

		Workflow:
				Pull artifacts from the repository.
				Deploy to the target environment.
				Run smoke tests or post-deployment validations.

		Benefits:
				Ensures only successfully built and tested artifacts reach production.
				Reduces risk of broken releases and increases confidence in deployments.

6. Feedback Loop :

			Continuous improvement and rapid problem detection.

		Workflow:
				Build tools and test frameworks provide immediate feedback to developers.
				Monitoring tools (Prometheus, Grafana, ELK stack) track production health.
				Issues feed back into the DevOps cycle for fixes.